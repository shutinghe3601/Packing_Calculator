<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case Packing Optimization</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }
        .input-container {
            text-align: center;
            padding: 20px;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        .input-container input {
            display: block;
            margin: 10px auto;
            padding: 8px;
            width: 80%;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .input-container button {
            margin-top: 10px;
            padding: 10px 20px;
            border: none;
            background-color: #4CAF50;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }
        .input-container button:hover {
            background-color: #45a049;
        }
        .output-container {
            margin-top: 20px;
            text-align: center;
        }
        table {
            margin: 0 auto;
            border-collapse: collapse;
            width: 80%;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
    <script type="text/javascript" src="../data/sample_locData.js"></script>
    <script type="text/javascript" src="../data/sample_caseData.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script>
        // Inline script uses caseData and locData
        console.log(locData, caseData); // This will work if the data files are loaded first
    </script>
</head>
<body>
    <div class="input-container">
        <!-- <label for="warehouseNumber">Input Warehouse Number</label>
        <input type="text" id="warehouseNumber" placeholder="Enter warehouse number"> -->
        <style>
            .aligned-input {
                display: block;
                margin: 10px auto;
                padding: 8px;
                width: 80%;
                border: 1px solid #ccc;
                border-radius: 4px;
            }
        </style>

        <label for="warehouseNumber">Select Warehouse Number</label>
        <div style="margin-bottom: 10px;"></div> <!-- Adds a 15px space gap -->
        <select id="warehouseNumber" class="aligned-input">
            <option value="101">101</option>
        </select>

        <div style="margin-bottom: 15px;"></div> <!-- Adds a 15px space gap -->

        <label for="locationNumber">Input Location Number</label>
        <input type="text" id="locationNumber" placeholder="Enter location number">

        <label for="skuId">Input SKU ID</label>
        <input type="text" id="skuId" placeholder="Enter SKU ID">

        <button onclick="handleSubmit()">Submit</button>

        <div class="output-container" id="outputContainer"></div>
    </div>
    <script>
        async function handleSubmit() {
            const warehouseNumber = document.getElementById('warehouseNumber').value;
            const locationNumber = document.getElementById('locationNumber').value;
            const skuId = document.getElementById('skuId').value;

            try {
                const result = optimizeCasePacking(
                    warehouseNumber,
                    locationNumber,
                    skuId,
                    locData,
                    caseData
                );

                const outputContainer = document.getElementById('outputContainer');
                const { totalCases, packingOrientations } = result;
                const loc = locData.find(
                    (l) => l.warehouse_number.toString() === warehouseNumber && l.location_number.toString() === locationNumber
                );
                const item = caseData.find((i) => i.sku_id.toString() === skuId);

                const locDims = [loc.width_inch, loc.depth_inch, loc.height_inch];
                const caseDims = [item.case_width, item.case_length, item.case_height];
                const skuName = item.name;

                if (caseDims.every(dim => dim === 0)) {
                    outputContainer.innerHTML = `
                        <h3>Results</h3>
                        <p><strong>SKU Name:</strong> ${skuName}</p>
                        <p><strong>Location Dimensions:</strong> ${locDims.join(' x ')}</p>
                        <p><strong>Case Dimensions:</strong> ${caseDims.join(' x ')}</p>
                        <p style="color: red;">This SKU has invalid dimension data in the system. Please remeasure for accurate results.</p>
                    `;
                    return;
                }

                let rows = packingOrientations.map((orientation, index) => `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${orientation.orientation.join(' x ')}</td>
                        <td>${orientation.count}</td>
                    </tr>
                `).join('');

                outputContainer.innerHTML = `
                    <h3>Results</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Orientation</th>
                                <th>Number of Cases</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rows}
                        </tbody>
                    </table>
                    <p><strong>SKU Name:</strong> ${skuName}</p>
                    <p><strong>Total Cases:</strong> ${totalCases}</p>
                    <p><strong>Location Dimensions:</strong> ${locDims.join(' x ')}</p>
                    <p><strong>Case Dimensions:</strong> ${caseDims.join(' x ')}</p>
                `;
                // Add 3D Plot
                const plotContainer = document.createElement('div');
                plotContainer.id = 'plotContainer';
                outputContainer.appendChild(plotContainer);

                create3DPlot(caseDims, locDims);
            } catch (error) {
                const outputContainer = document.getElementById('outputContainer');
                outputContainer.innerHTML = `<p style="color: red;">Error: ${error.message}</p>`;
            }
        }

        function create3DPlot(caseDims, locDims) {
            // Retrieve the plot container
            const plotContainer = document.getElementById('plotContainer');

            // Clear any previous canvas
            while (plotContainer.firstChild) {
                plotContainer.removeChild(plotContainer.firstChild);
            }

            // Create scene, camera, and renderer
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(600, 300); // Fixed canvas size
            renderer.setClearColor(0xf5f5dc); // Beige white background
            plotContainer.appendChild(renderer.domElement);

            // Add 3D space (bounding box mesh)
            const [locWidth, locDepth, locHeight] = locDims;
            const spaceGeometry = new THREE.BoxGeometry(locWidth, locHeight, locDepth);
            const spaceMaterial = new THREE.MeshBasicMaterial({
                color: 0x87ceeb, // Light blue
                wireframe: true,
                transparent: true,
                opacity: 0.5,
            });
            const spaceMesh = new THREE.Mesh(spaceGeometry, spaceMaterial);
            spaceMesh.position.set(locWidth / 2, locHeight / 2, locDepth / 2); // Center the space
            scene.add(spaceMesh);

            // Add object inside the 3D space
            const scaleFactor = 1; // Scale the object
            const [objWidth, objDepth, objHeight] = caseDims.map(dim => dim * scaleFactor);
            const objGeometry = new THREE.BoxGeometry(objWidth, objHeight, objDepth);

            // Material for the object
            const objMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 }); // Orange
            const objectMesh = new THREE.Mesh(objGeometry, objMaterial);
            objectMesh.position.set(objWidth / 2, objHeight / 2, objDepth / 2); // Place on the floor
            scene.add(objectMesh);

            // Add edges for the object for better visibility
            const edges = new THREE.EdgesGeometry(objGeometry);
            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000 }); // Black for edges
            const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
            objectMesh.add(edgeLines);

            // Add axes for reference
            const axisLength = Math.max(...locDims);
            addAxis(scene, [0, 0, 0], [axisLength, 0, 0], 0xff0000); // X-axis (red)
            addAxis(scene, [0, 0, 0], [0, axisLength, 0], 0x00ff00); // Y-axis (green)
            addAxis(scene, [0, 0, 0], [0, 0, axisLength], 0x0000ff); // Z-axis (blue)

            // Set camera position and angle
            camera.position.set(locWidth * 1.5, locHeight * 1.2, locDepth * 1.5); // Adjust for top-left view
            camera.lookAt(locWidth / 2, locHeight / 2, locDepth / 2);

            // Render the scene
            renderer.render(scene, camera);
        }

        function addAxis(scene, start, end, color) {
            const material = new THREE.LineBasicMaterial({ color: color });
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(...start),
                new THREE.Vector3(...end),
            ]);
            const axis = new THREE.Line(geometry, material);
            scene.add(axis);
        }


        // function create3DPlot(caseDims, locDims) {
        //     // Retrieve the plot container
        //     const plotContainer = document.getElementById('plotContainer');

        //     // Clear any previous canvas
        //     while (plotContainer.firstChild) {
        //         plotContainer.removeChild(plotContainer.firstChild);
        //     }

        //     // Create scene, camera, and renderer
        //     const scene = new THREE.Scene();
        //     const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 1000);
        //     const renderer = new THREE.WebGLRenderer();
        //     renderer.setSize(600, 300); // Fixed canvas size
        //     plotContainer.appendChild(renderer.domElement);

        //     // Axes
        //     const axisLength = Math.max(...locDims);
        //     addAxis(scene, [0, 0, 0], [axisLength, 0, 0], 0xff0000); // X-axis (red)
        //     addAxis(scene, [0, 0, 0], [0, axisLength, 0], 0x00ff00); // Y-axis (green)
        //     addAxis(scene, [0, 0, 0], [0, 0, axisLength], 0x0000ff); // Z-axis (blue)

        //     // Add the case object
        //     const [objWidth, objDepth, objHeight] = caseDims;
        //     const geometry = new THREE.BoxGeometry(objWidth, objHeight, objDepth);
        //     const materialBox = new THREE.MeshBasicMaterial({ color: 0xffa500 });
        //     const box = new THREE.Mesh(geometry, materialBox);
        //     box.position.set(objWidth / 2, objHeight / 2, objDepth / 2); // Place on the floor
        //     scene.add(box);

        //     // Set camera
        //     camera.position.set(50, 30, 50);
        //     camera.lookAt(20, 10, 20);

        //     renderer.render(scene, camera);
        // }

        // function addAxis(scene, start, end, color) {
        //     const material = new THREE.LineBasicMaterial({ color: color });
        //     const geometry = new THREE.BufferGeometry().setFromPoints([
        //         new THREE.Vector3(...start),
        //         new THREE.Vector3(...end)
        //     ]);
        //     const axis = new THREE.Line(geometry, material);
        //     scene.add(axis);
        // }

        function optimizeCasePacking(warehouseNumber, locationNumber, skuId, locData, caseData) {
            const loc = locData.find(
                (l) => l.warehouse_number.toString() === warehouseNumber && l.location_number.toString() === locationNumber
            );
            if (!loc) throw new Error('Location not found for the given warehouse and location number.');

            const locDims = [loc.width_inch, loc.depth_inch, loc.height_inch];

            const item = caseData.find((i) => i.sku_id.toString() === skuId);
            if (!item) throw new Error('Item not found for the given SKU ID.');

            const caseDims = [item.case_width, item.case_length, item.case_height];

            const orientationList = generatePermutations(caseDims);
            let totalCases = 0;
            const packingOrientations = [];

            while (true) {
                let bestOrientation = null;
                let maxCases = 0;
                let remainingLocDims = null;

                for (const orientation of orientationList) {
                    const cases = calculateFitCount(locDims, orientation);
                    if (cases > maxCases) {
                        maxCases = cases;
                        bestOrientation = orientation;
                        remainingLocDims = calculateRemainingSpace(locDims, orientation);
                    }
                }

                if (maxCases === 0) break;

                totalCases += maxCases;
                packingOrientations.push({ orientation: bestOrientation, count: maxCases });
                locDims[0] = remainingLocDims[0];
                locDims[1] = remainingLocDims[1];
                locDims[2] = remainingLocDims[2];
            }

            return { totalCases, packingOrientations };
        }

        function calculateRemainingSpace(locDims, orientation) {
            const [W, D, H] = locDims;
            const [a, b, c] = orientation;
            return [W % a, D % b, H % c];
        }

        function calculateFitCount(locDims, orientation) {
            const [W, D, H] = locDims;
            const [a, b, c] = orientation;
            return Math.floor(W / a) * Math.floor(D / b) * Math.floor(H / c);
        }

        function generatePermutations(array) {
            if (array.length === 0) return [[]];
            const result = [];
            for (let i = 0; i < array.length; i++) {
                const rest = array.slice(0, i).concat(array.slice(i + 1));
                const permutations = generatePermutations(rest);
                for (const perm of permutations) {
                    result.push([array[i], ...perm]);
                }
            }
            return result;
        }
    </script>
</body>
</html>
